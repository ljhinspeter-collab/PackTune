import type { User, Artist, Song, CollectedSong, TradePost, TradeOffer } from '../types';

const USERS_KEY = 'soundmap_users';
const TRADES_KEY = 'soundmap_trades';
const CURRENT_USER_ID_KEY = 'soundmap_current_user_id';

class DataService {

  constructor() {
    this.seedInitialData();
  }

  private seedInitialData() {
    if (!localStorage.getItem(USERS_KEY)) {
      const initialUsers: User[] = [
        { id: 'user-1', name: "You", bio: "Just here for the music!", pfpUrl: `https://i.pravatar.cc/150?u=user-1`, collection: [], favoriteArtists: [], friendIds: [] },
        // NOTE: In a real-world scenario, other users would be fetched from a server.
        // For this simulation, we only create the primary user.
      ];
      
      this.saveUsers(initialUsers);
      this.setCurrentUserId(initialUsers[0].id);
      localStorage.setItem(TRADES_KEY, JSON.stringify([]));
    }
  }

  // User methods
  getUsers = (): User[] => JSON.parse(localStorage.getItem(USERS_KEY) || '[]');
  saveUsers = (users: User[]) => localStorage.setItem(USERS_KEY, JSON.stringify(users));
  getCurrentUserId = (): string => localStorage.getItem(CURRENT_USER_ID_KEY) || this.getUsers()[0]?.id;
  setCurrentUserId = (id: string) => localStorage.setItem(CURRENT_USER_ID_KEY, id);

  // TradePost methods
  getTradePosts = (): TradePost[] => JSON.parse(localStorage.getItem(TRADES_KEY) || '[]');
  saveTradePosts = (trades: TradePost[]) => localStorage.setItem(TRADES_KEY, JSON.stringify(trades));

  createTradePost(owner: User, songToTrade: CollectedSong, seeking: string): TradePost {
    const newPost: TradePost = {
      id: `trade-${Date.now()}`,
      ownerId: owner.id,
      ownerName: owner.name,
      ownerPfpUrl: owner.pfpUrl,
      songToTrade,
      seeking,
      offers: [],
      status: 'open',
      createdAt: Date.now()
    };

    const allTrades = this.getTradePosts();
    this.saveTradePosts([newPost, ...allTrades]);
    return newPost;
  }

  cancelTradePost(tradeId: string): TradePost[] {
    const allTrades = this.getTradePosts();
    const updatedTrades = allTrades.filter(t => t.id !== tradeId);
    this.saveTradePosts(updatedTrades);
    return updatedTrades;
  }

  // TradeOffer methods
  createOffer(tradeId: string, offerer: User, songsOffered: CollectedSong[]): TradeOffer {
    const newOffer: TradeOffer = {
      id: `offer-${Date.now()}`,
      tradeId,
      offeredById: offerer.id,
      offeredByName: offerer.name,
      offeredByPfpUrl: offerer.pfpUrl,
      songsOffered,
      status: 'pending'
    };
    return newOffer;
  }
  
  processOffer(tradeId: string, offerId: string, decision: 'accepted' | 'declined'): { updatedUsers: User[], updatedTradePosts: TradePost[] } {
    let allTrades = this.getTradePosts();
    let allUsers = this.getUsers();
    
    const tradeIndex = allTrades.findIndex(t => t.id === tradeId);
    if (tradeIndex === -1) return { updatedUsers: allUsers, updatedTradePosts: allTrades };

    const trade = allTrades[tradeIndex];
    const offerIndex = trade.offers.findIndex(o => o.id === offerId);
    if (offerIndex === -1) return { updatedUsers: allUsers, updatedTradePosts: allTrades };

    if (decision === 'declined') {
      trade.offers[offerIndex].status = 'declined';
    } else if (decision === 'accepted') {
      const offer = trade.offers[offerIndex];
      const tradeOwner = allUsers.find(u => u.id === trade.ownerId);
      const offerer = allUsers.find(u => u.id === offer.offeredById);

      if (tradeOwner && offerer) {
        // Remove traded songs from original owners
        tradeOwner.collection = tradeOwner.collection.filter(s => s.id !== trade.songToTrade.id);
        offerer.collection = offerer.collection.filter(s => !offer.songsOffered.some(os => os.id === s.id));
        
        // Add songs to new owners
        const tradedSongToOfferer = { ...trade.songToTrade, ownerId: offerer.id };
        const offeredSongsToOwner = offer.songsOffered.map(s => ({ ...s, ownerId: tradeOwner.id }));
        
        tradeOwner.collection.push(...offeredSongsToOwner);
        offerer.collection.push(tradedSongToOfferer);

        // Update users array
        allUsers = allUsers.map(u => {
            if (u.id === tradeOwner.id) return tradeOwner;
            if (u.id === offerer.id) return offerer;
            return u;
        });

        // Update trade and offers status
        trade.status = 'closed';
        trade.offers.forEach(o => {
            o.status = o.id === offerId ? 'accepted' : 'declined';
        });
      }
    }
    
    allTrades[tradeIndex] = trade;
    this.saveUsers(allUsers);
    this.saveTradePosts(allTrades);
    
    return { updatedUsers: allUsers, updatedTradePosts: allTrades };
  }
}

export const dataService = new DataService();