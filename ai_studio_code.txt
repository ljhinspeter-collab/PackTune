import React, { createContext, useState, useEffect, ReactNode, useCallback } from 'react';
import type { User, Artist, Song, CollectedSong, TradePost, TradeOffer } from '../types';
import { dataService } from '../services/dataService';
import { Rarity } from '../types';
import { mythicSerialService } from '../services/mythicService';

interface IUserContext {
  currentUser: User | null;
  users: User[];
  tradePosts: TradePost[];
  updateCurrentUser: (userData: Partial<User>) => void;
  addSongsToCollection: (songs: Song[]) => void;
  createTradePost: (songToTrade: CollectedSong, seeking: string) => void;
  makeOffer: (tradePost: TradePost, songsOffered: CollectedSong[]) => void;
  cancelTradePost: (tradeId: string) => void;
  reviewOffer: (tradeId: string, offerId: string, decision: 'accepted' | 'declined') => void;
  addFriend: (friendId: string) => void;
  removeFriend: (friendId: string) => void;
  setFavoriteArtists: (artists: Artist[]) => void;
}

export const UserContext = createContext<IUserContext | null>(null);

export const UserProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
  const [currentUser, setCurrentUser] = useState<User | null>(null);
  const [users, setUsers] = useState<User[]>([]);
  const [tradePosts, setTradePosts] = useState<TradePost[]>([]);
  
  // Initialize data from DataService on mount
  useEffect(() => {
    const allUsers = dataService.getUsers();
    setUsers(allUsers);

    const currentUserId = dataService.getCurrentUserId();
    const userToSet = allUsers.find(u => u.id === currentUserId) || allUsers[0];
    setCurrentUser(userToSet);
    
    setTradePosts(dataService.getTradePosts());
  }, []);

  const updateCurrentUser = (userData: Partial<User>) => {
    if (!currentUser) return;
    const updatedUser = { ...currentUser, ...userData };
    setCurrentUser(updatedUser);
    const updatedUsers = users.map(u => u.id === updatedUser.id ? updatedUser : u);
    setUsers(updatedUsers);
    dataService.saveUsers(updatedUsers);
  };

  const setFavoriteArtists = (artists: Artist[]) => {
    if (!currentUser) return;
    updateCurrentUser({ favoriteArtists: artists });
  };
  
  const addSongsToCollection = (songs: Song[]) => {
      if (!currentUser) return;
      
      const newCollectedSongs: CollectedSong[] = songs.map(song => {
          let serialNumber: number | undefined = undefined;
          if (song.rarity === Rarity.Mythic) {
              serialNumber = mythicSerialService.getNextSerialNumber(song.id);
          }
          return {
              id: `${song.id}-${Date.now()}-${Math.random()}`,
              song,
              serialNumber,
              ownerId: currentUser.id
          };
      });
      
      updateCurrentUser({ collection: [...currentUser.collection, ...newCollectedSongs] });
  };
  
  const addFriend = (friendId: string) => {
    if (!currentUser || currentUser.friendIds.includes(friendId)) return;
    updateCurrentUser({ friendIds: [...currentUser.friendIds, friendId] });
  };

  const removeFriend = (friendId: string) => {
    if (!currentUser) return;
    updateCurrentUser({ friendIds: currentUser.friendIds.filter(id => id !== friendId) });
  };

  const createTradePost = (songToTrade: CollectedSong, seeking: string) => {
    if (!currentUser) return;
    const newPost = dataService.createTradePost(currentUser, songToTrade, seeking);
    setTradePosts(prev => [newPost, ...prev]);
  };
  
  const cancelTradePost = (tradeId: string) => {
    const updatedPosts = dataService.cancelTradePost(tradeId);
    setTradePosts(updatedPosts);
  }

  const makeOffer = (tradePost: TradePost, songsOffered: CollectedSong[]) => {
    if (!currentUser) return;
    const newOffer = dataService.createOffer(tradePost.id, currentUser, songsOffered);
    
    const updatedPosts = tradePosts.map(post => {
      if (post.id === tradePost.id) {
        return { ...post, offers: [...post.offers, newOffer] };
      }
      return post;
    });
    setTradePosts(updatedPosts);
    dataService.saveTradePosts(updatedPosts);
  };
  
  const reviewOffer = useCallback((tradeId: string, offerId: string, decision: 'accepted' | 'declined') => {
      const { updatedUsers, updatedTradePosts } = dataService.processOffer(tradeId, offerId, decision);
      setUsers(updatedUsers);
      setTradePosts(updatedTradePosts);
      // Update current user state if they were involved in the trade
      const updatedCurrentUser = updatedUsers.find(u => u.id === currentUser?.id);
      if (updatedCurrentUser) {
          setCurrentUser(updatedCurrentUser);
      }
  }, [currentUser]);


  return (
    <UserContext.Provider value={{ 
        currentUser, users, tradePosts, updateCurrentUser, 
        addSongsToCollection, createTradePost, makeOffer, cancelTradePost,
        reviewOffer, addFriend, removeFriend, setFavoriteArtists
    }}>
      {children}
    </UserContext.Provider>
  );
};